1.因为在处理中断的时候，如果公用一个处理函数，首先对errorcode的处理会有难度，其次处理程序无法得之是哪个中断调用而来，也就无法很好地设置中断号了。

2.因为每个中断都有权限，虽然user/softint调用的是int 14，但我们在IDT中设置的权限为0，即这是一个内核中断，因此当用户程序触发这个中断时，CPU产生int 13的中断来进行保护。

3.这个主要原因在于在设置IDT的时候权限为0或者是3。如果权限为0，说明只有内核能处理中断，此时用户出发breakpoint会产生general protection fault。而如果权限为3，说明用户有权限处理breakpoint的中断，就会产生break point exception。在这个lab中需要用户能处理breakpoint，因此将其权限设置为3。

4.主要在于在IDT中对于每个中断都设置的权限，如果用户出发了一个只有内核能处理的中断就会触发general protection fault，以此来保护内核不被任意修改。